
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Python 2.2 有什么新变化 &#8212; Python 3.8.20 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.8.20 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="Python 2.1 有什么新变化" href="2.1.html" />
    <link rel="prev" title="Python 2.3 有什么新变化" href="2.3.html" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.2.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python 2.2 有什么新变化</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#peps-252-and-253-type-and-class-changes">PEP 252 和 253：类型和类的修改</a><ul>
<li><a class="reference internal" href="#old-and-new-classes">旧式类和新式类</a></li>
<li><a class="reference internal" href="#descriptors">描述器</a></li>
<li><a class="reference internal" href="#multiple-inheritance-the-diamond-rule">多重继承：钻石规则</a></li>
<li><a class="reference internal" href="#attribute-access">属性访问</a></li>
<li><a class="reference internal" href="#related-links">相关链接</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-234-iterators">PEP 234: 迭代器</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 简单的生成器</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: 统一长整数和整数</a></li>
<li><a class="reference internal" href="#pep-238-changing-the-division-operator">PEP 238：修改除法运算符</a></li>
<li><a class="reference internal" href="#unicode-changes">Unicode 的改变</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 嵌套的作用域</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a></li>
<li><a class="reference internal" href="#interpreter-changes-and-fixes">解释器的改变和修正</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="2.3.html"
                        title="上一章">Python 2.3 有什么新变化</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="2.1.html"
                        title="下一章">Python 2.1 有什么新变化</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/whatsnew/2.2.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Python 2.1 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Python 2.3 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.8.20 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-2">
<h1>Python 2.2 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-2" title="永久链接至标题">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">作者</dt>
<dd class="field-odd"><p>A.M. Kuchling</p>
</dd>
</dl>
<section id="introduction">
<h2>概述<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p>本文本介绍了 Python 2.2.2 的新增特性，该版本发布于 2002 年 10 月 14日。 Python 2.2.2 是 Python 2.2 的问题修正发布版，最初发布于 2001 年 12 月 21 日。</p>
<p>Python 2.2 可以被看作是 &quot;清理发布版&quot;。 有一些特性如生成器和迭代器等是全新的，但大多数变化，尽管可能是重大而深远的，都是为了清理语言设计中的不规范和阴暗角落。</p>
<p>本文并不试图提供对新特性的完整规范说明，而是提供一个便捷的概览。 要获取全部细节，你应该参阅 Python 2.2 的文档，比如 <a class="reference external" href="https://docs.python.org/2.2/lib/lib.html">Python 库参考</a> 和 <a class="reference external" href="https://docs.python.org/2.2/ref/ref.html">Python 参考指南</a>。 如果你想要了解某项更改的完整实现和设计理念，请参阅特定新特性的 PEP。</p>
</section>
<section id="peps-252-and-253-type-and-class-changes">
<h2>PEP 252 和 253：类型和类的修改<a class="headerlink" href="#peps-252-and-253-type-and-class-changes" title="永久链接至标题">¶</a></h2>
<p>Python 2.2 中最大且影响最深远的改变是针对 Python 的对象和类模型。 这些变化应该是向下兼容的，因此你的代码将能继续运行而无需修改，但这些变化提供了一些很棒的新功能。 在开始本文最长和最复杂的部分之前，我提供对这些变化的概览并附带一些注释。</p>
<p>A long time ago I wrote a Web page listing flaws in Python's design.  One of the
most significant flaws was that it's impossible to subclass Python types
implemented in C.  In particular, it's not possible to subclass built-in types,
so you can't just subclass, say, lists in order to add a single useful method to
them. The <code class="xref py py-mod docutils literal notranslate"><span class="pre">UserList</span></code> module provides a class that supports all of the
methods of lists and that can be subclassed further, but there's lots of C code
that expects a regular Python list and won't accept a <code class="xref py py-class docutils literal notranslate"><span class="pre">UserList</span></code>
instance.</p>
<p>Python 2.2 修正了此问题，并在此过程中添加了一些令人激动的新功能。 简明概述如下:</p>
<ul class="simple">
<li><p>你可以继承内置类型，例如列表和整数，并且你的子类应该在任何需要原始类型的地方正常工作。这使得 Python 的面向对象编程更加灵活和强大。</p></li>
<li><p>现在，除了之前版本的 Python 中可用的实例方法外，还可以定义静态方法和类方法。这使得你可以更灵活地组织类的行为。</p></li>
<li><p>It's also possible to automatically call methods on accessing or setting an
instance attribute by using a new mechanism called <em class="dfn">properties</em>.  Many uses
of <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> can be rewritten to use properties instead, making the
resulting code simpler and faster.  As a small side benefit, attributes can now
have docstrings, too.</p></li>
<li><p>可以使用 __slots__ 限制实例的合法属性列表，从而防止拼写错误，并且在未来的 Python 版本中可能进行更多的优化。</p></li>
</ul>
<p>一些用户对这些变化表示担忧。确实，他们说，新功能很棒，可以实现以前版本的 Python 无法做到的各种技巧，但它们也使语言变得更加复杂。一些人表示，他们一直推荐 Python 是因为它的简单性，现在感觉这种简单性正在丧失。</p>
<p>个人而言，我认为没有必要担心。许多新功能相当深奥，你可以编写大量 Python 代码而不需要了解它们。编写一个简单的类并不比以前更难，因此除非确实需要，否则你不必费心去学习或教授这些新功能。一些以前只有在 C 语言中才能实现的非常复杂的任务，现在可以用纯 Python 实现，在我看来，这一切都更好了。</p>
<p>我不会尝试涵盖所有为了使新功能生效而需要的每一个边缘情况和小改动。相反，本节将只勾勒出大致的轮廓。有关 Python 2.2 新对象模型的更多信息，请参见 <a class="reference internal" href="#sect-rellinks"><span class="std std-ref">相关链接</span></a> 的“相关链接”部分。</p>
<section id="old-and-new-classes">
<h3>旧式类和新式类<a class="headerlink" href="#old-and-new-classes" title="永久链接至标题">¶</a></h3>
<p>首先，你应该知道 Python 2.2 实际上有两种类型的类：经典类（或旧式类）和新式类。旧式类模型与早期版本的 Python 中的类模型完全相同。本节描述的所有新功能仅适用于新式类。这种分歧并不是永久的；最终，旧式类将被淘汰，可能在 Python 3.0 中被移除。</p>
<p>那么如何定义一个新式类呢？你可以通过继承一个现有的新式类来实现。大多数 Python 内置类型，如整数、列表、字典，甚至文件，现在都是新式类。此外，还添加了一个名为 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的新式类，它是所有内置类型的基类，因此如果没有合适的内置类型，你可以直接继承 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 类：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This means that <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> statements that don't have any base classes are
always classic classes in Python 2.2.  (Actually you can also change this by
setting a module-level variable named <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metaclass__</span></code> --- see <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0253"><strong>PEP 253</strong></a>
for the details --- but it's easier to just subclass <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.)</p>
<p>内置类型的类型对象在 Python 2.2 中作为内置对象提供，使用了一种巧妙的技巧命名。Python 一直有名为 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>、<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 的内置函数。在 Python 2.2 中，它们不再是函数，而是作为被调用时表现为工厂的类型对象。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="go">123</span>
</pre></div>
</div>
<p>To make the set of types complete, new type objects such as <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict()</span></code></a> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">file()</span></code> have been added.  Here's a more interesting example, adding a
<code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code> method to file objects:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LockableFile</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">lock</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">fcntl</span>
        <span class="k">return</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">lockf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">operation</span><span class="p">,</span>
                           <span class="n">length</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
</pre></div>
</div>
<p>The now-obsolete <code class="xref py py-mod docutils literal notranslate"><span class="pre">posixfile</span></code> module contained a class that emulated all of
a file object's methods and also added a <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code> method, but this class
couldn't be passed to internal functions that expected a built-in file,
something which is possible with our new <code class="xref py py-class docutils literal notranslate"><span class="pre">LockableFile</span></code>.</p>
</section>
<section id="descriptors">
<h3>描述器<a class="headerlink" href="#descriptors" title="永久链接至标题">¶</a></h3>
<p>In previous versions of Python, there was no consistent way to discover what
attributes and methods were supported by an object. There were some informal
conventions, such as defining <code class="xref py py-attr docutils literal notranslate"><span class="pre">__members__</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">__methods__</span></code>
attributes that were lists of names, but often the author of an extension type
or a class wouldn't bother to define them.  You could fall back on inspecting
the <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> of an object, but when class inheritance or an arbitrary
<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> hook were in use this could still be inaccurate.</p>
<p>新类模型的一个核心理念是正式化了使用描述符来描述对象属性的 API。描述符指定属性的值，说明它是方法还是字段。通过描述符 API，静态方法和类方法成为可能，以及其他更复杂的构造。</p>
<p>属性描述符是存在于类对象内部的对象，它们自身具有一些属性。描述符协议由三个主要方法组成：</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 是属性的名称。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 是属性的文档字符串。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__get__(object)</span></code> 是一个从 <em>object</em> 中提取属性值的方法。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__set__(object,</span> <span class="pre">value)</span></code> 将 <em>object</em> 上的属性设为 <em>value</em>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__delete__(object,</span> <span class="pre">value)</span></code> 将删除 <em>object</em> 的 <em>value</em> 属性。</p></li>
</ul>
<p>例如，当你写下 <code class="docutils literal notranslate"><span class="pre">obj.x</span></code>，Python 实际要执行的步骤是:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">x</span>
<span class="n">descriptor</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>For methods, <code class="xref py py-meth docutils literal notranslate"><span class="pre">descriptor.__get__()</span></code> returns a temporary object that's
callable, and wraps up the instance and the method to be called on it. This is
also why static methods and class methods are now possible; they have
descriptors that wrap up just the method, or the method and the class.  As a
brief explanation of these new kinds of methods, static methods aren't passed
the instance, and therefore resemble regular functions.  Class methods are
passed the class of the object, but not the object itself.  Static and class
methods are defined like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> function takes the function <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code>, and returns it
wrapped up in a descriptor so it can be stored in the class object.  You might
expect there to be special syntax for creating such methods (<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">static</span> <span class="pre">f</span></code>,
<code class="docutils literal notranslate"><span class="pre">defstatic</span> <span class="pre">f()</span></code>, or something like that) but no such syntax has been defined
yet; that's been left for future versions of Python.</p>
<p>更多的新功能，如 __slots__ 和属性，也作为新类型的描述符实现。编写一个实现新功能的描述符类并不困难。例如，可以编写一个描述符类，使其能够为方法编写类似 Eiffel 风格的前置条件和后置条件。使用该功能的类可能定义如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">eiffel</span> <span class="kn">import</span> <span class="n">eiffelmethod</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="c1"># The actual function</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">pre_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Check preconditions</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">post_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Check postconditions</span>
        <span class="o">...</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">eiffelmethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pre_f</span><span class="p">,</span> <span class="n">post_f</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that a person using the new <code class="xref py py-func docutils literal notranslate"><span class="pre">eiffelmethod()</span></code> doesn't have to understand
anything about descriptors.  This is why I think the new features don't increase
the basic complexity of the language. There will be a few wizards who need to
know about it in order to write <code class="xref py py-func docutils literal notranslate"><span class="pre">eiffelmethod()</span></code> or the ZODB or whatever,
but most users will just write code on top of the resulting libraries and ignore
the implementation details.</p>
</section>
<section id="multiple-inheritance-the-diamond-rule">
<h3>多重继承：钻石规则<a class="headerlink" href="#multiple-inheritance-the-diamond-rule" title="永久链接至标题">¶</a></h3>
<p>通过改变名称解析规则，多重继承也变得更加有用。  请看下面这组类（图表摘自 <span class="target" id="index-42"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0253"><strong>PEP 253</strong></a> ，作者 Guido van Rossum）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>      <span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
        <span class="o">^</span> <span class="o">^</span>  <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
       <span class="o">/</span>   \
      <span class="o">/</span>     \
     <span class="o">/</span>       \
    <span class="o">/</span>         \
<span class="k">class</span> <span class="nc">B</span>     <span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">^</span>         <span class="o">^</span>  <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
     \       <span class="o">/</span>
      \     <span class="o">/</span>
       \   <span class="o">/</span>
        \ <span class="o">/</span>
      <span class="k">class</span> <span class="nc">D</span>
</pre></div>
</div>
<p>The lookup rule for classic classes is simple but not very smart; the base
classes are searched depth-first, going from left to right.  A reference to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">D.save()</span></code> will search the classes <code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, and then
<code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>, where <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> would be found and returned.  <code class="xref py py-meth docutils literal notranslate"><span class="pre">C.save()</span></code>
would never be found at all.  This is bad, because if <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>'s <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code>
method is saving some internal state specific to <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, not calling it will
result in that state never getting saved.</p>
<p>新式类遵循一种不同的算法，虽然解释起来有点复杂，但在这种情况下能做正确的事情。（请注意，Python 2.3 改变了这个算法，在大多数情况下会产生相同的结果，但对于非常复杂的继承图会产生更有用的结果。）</p>
<ol class="arabic simple">
<li><p>List all the base classes, following the classic lookup rule and include a
class multiple times if it's visited repeatedly.  In the above example, the list
of visited classes is [<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>].</p></li>
<li><p>Scan the list for duplicated classes.  If any are found, remove all but one
occurrence, leaving the <em>last</em> one in the list.  In the above example, the list
becomes [<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>] after dropping
duplicates.</p></li>
</ol>
<p>Following this rule, referring to <code class="xref py py-meth docutils literal notranslate"><span class="pre">D.save()</span></code> will return <code class="xref py py-meth docutils literal notranslate"><span class="pre">C.save()</span></code>,
which is the behaviour we're after.  This lookup rule is the same as the one
followed by Common Lisp.  A new built-in function, <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>, provides a way
to get at a class's superclasses without having to reimplement Python's
algorithm. The most commonly used form will be  <code class="docutils literal notranslate"><span class="pre">super(class,</span> <span class="pre">obj)</span></code>, which
returns  a bound superclass object (not the actual class object).  This form
will be used in methods to call a method in the superclass; for example,
<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>'s <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> method would look like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">save</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Call superclass .save()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="c1"># Save D&#39;s private information here</span>
        <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 在以 <code class="docutils literal notranslate"><span class="pre">super(class)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">super(class1,</span> <span class="pre">class2)</span></code> 形式调用时也可以返回未绑定的超类对象，但这可能并不常用。</p>
</section>
<section id="attribute-access">
<h3>属性访问<a class="headerlink" href="#attribute-access" title="永久链接至标题">¶</a></h3>
<p>A fair number of sophisticated Python classes define hooks for attribute access
using <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>; most commonly this is done for convenience, to make
code more readable by automatically mapping an attribute access such as
<code class="docutils literal notranslate"><span class="pre">obj.parent</span></code> into a method call such as <code class="docutils literal notranslate"><span class="pre">obj.get_parent</span></code>.  Python 2.2 adds
some new ways of controlling attribute access.</p>
<p>首先，新式类仍然支持 <code class="docutils literal notranslate"><span class="pre">__getattr__(attr_name)</span></code>，关于它的任何内容都没有改变。  和以前一样，当试图访问 <code class="docutils literal notranslate"><span class="pre">obj.foo</span></code> 时，如果在实例的字典中找不到名为 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 的属性，就会调用它。</p>
<p>New-style classes also support a new method,
<code class="docutils literal notranslate"><span class="pre">__getattribute__(attr_name)</span></code>.  The difference between the two methods is
that <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> is <em>always</em> called whenever any attribute is
accessed, while the old <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> is only called if <code class="docutils literal notranslate"><span class="pre">foo</span></code> isn't
found in the instance's dictionary.</p>
<p>However, Python 2.2's support for <em class="dfn">properties</em> will often be a simpler way
to trap attribute references.  Writing a <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> method is
complicated because to avoid recursion you can't use regular attribute accesses
inside them, and instead have to mess around with the contents of
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>. <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> methods also end up being called by Python
when it checks for other methods such as <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__coerce__()</span></code>,
and so have to be written with this in mind. Finally, calling a function on
every attribute access results in a sizable performance loss.</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a> is a new built-in type that packages up three functions that
get, set, or delete an attribute, and a docstring.  For example, if you want to
define a <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> attribute that's computed, but also settable, you could
write:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_size</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">computation</span> <span class="o">...</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">def</span> <span class="nf">set_size</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">compute</span> <span class="n">something</span> <span class="n">based</span> <span class="n">on</span> <span class="n">the</span> <span class="n">size</span>
        <span class="ow">and</span> <span class="nb">set</span> <span class="n">internal</span> <span class="n">state</span> <span class="n">appropriately</span> <span class="o">...</span>

    <span class="c1"># Define a property.  The &#39;delete this attribute&#39;</span>
    <span class="c1"># method is defined as None, so the attribute</span>
    <span class="c1"># can&#39;t be deleted.</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_size</span><span class="p">,</span> <span class="n">set_size</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="s2">&quot;Storage size of this instance&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>That is certainly clearer and easier to write than a pair of
<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>/<a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> methods that check for the <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code>
attribute and handle it specially while retrieving all other attributes from the
instance's <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.  Accesses to <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> are also the only ones
which have to perform the work of calling a function, so references to other
attributes run at their usual speed.</p>
<p>最后，可以使用新的类属性 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 来限制对象上可以引用的属性列表。Python 对象通常非常动态，可以随时通过简单地 <code class="docutils literal notranslate"><span class="pre">obj.new_attr=1</span></code> 来定义一个新属性。新式类可以定义一个名为 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 的类属性，以将合法属性限制为特定的一组名称。一个例子可以更清楚地说明这一点：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;template&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">obj</span><span class="o">.</span><span class="n">template</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;Test&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">obj</span><span class="o">.</span><span class="n">template</span>
<span class="go">Test</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">newattr</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;C&#39; object has no attribute &#39;newattr&#39;</span>
</pre></div>
</div>
<p>注意，当尝试为未列在 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 中的属性赋值时，会引发 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。</p>
</section>
<section id="related-links">
<span id="sect-rellinks"></span><h3>相关链接<a class="headerlink" href="#related-links" title="永久链接至标题">¶</a></h3>
<p>本节只是对新特性进行了简要概述，提供了足够的解释以帮助你开始编程，但许多细节已被简化或忽略。想要获得更全面的了解，你可以去哪里呢？</p>
<p><a class="reference external" href="https://docs.python.org/dev/howto/descriptor.html">https://docs.python.org/dev/howto/descriptor.html</a> is a lengthy tutorial introduction to
the descriptor features, written by Guido van Rossum. If my description has
whetted your appetite, go read this tutorial next, because it goes into much
more detail about the new features while still remaining quite easy to read.</p>
<p>接下来，有两个相关的 PEP，即 <span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0252"><strong>PEP 252</strong></a> 和 <span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0253"><strong>PEP 253</strong></a>。<span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0252"><strong>PEP 252</strong></a> 标题为“使类型更像类”，涵盖了描述符 API。<span class="target" id="index-46"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0253"><strong>PEP 253</strong></a> 标题为“内置类型的子类型化”，描述了使内置对象可以进行子类型化的类型对象的更改。<span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0253"><strong>PEP 253</strong></a> 是这两个 PEP 中更复杂的一个，在某些点上，必要的类型和元类型解释可能会让人感到头疼。两个 PEP 都由 Guido van Rossum 编写和实现，并得到了 Zope Corp. 团队其他成员的实质性协助。</p>
<p>最后，还有最终的权威来源：源代码。大部分类型处理的机制都在 <code class="file docutils literal notranslate"><span class="pre">Objects/typeobject.c</span></code> 中，但只有在所有其他途径都用尽之后，包括在 python-list 或 python-dev 上发布问题后，才应求助于源代码。</p>
</section>
</section>
<section id="pep-234-iterators">
<h2>PEP 234: 迭代器<a class="headerlink" href="#pep-234-iterators" title="永久链接至标题">¶</a></h2>
<p>Python 2.2 的另一个重要新增功能是在 C 和 Python 两个层面上引入了迭代接口。对象可以定义如何被调用者循环遍历。</p>
<p>In Python versions up to 2.1, the usual way to make <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">obj</span></code> work is
to define a <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method that looks something like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nb">next</span> <span class="n">item</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> is more properly used to define an indexing operation on an
object so that you can write <code class="docutils literal notranslate"><span class="pre">obj[5]</span></code> to retrieve the sixth element.  It's a
bit misleading when you're using this only to support <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> loops.
Consider some file-like object that wants to be looped over; the <em>index</em>
parameter is essentially meaningless, as the class probably assumes that a
series of <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> calls will be made with <em>index</em> incrementing by
one each time.  In other words, the presence of the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method
doesn't mean that using <code class="docutils literal notranslate"><span class="pre">file[5]</span></code>  to randomly access the sixth element will
work, though it really should.</p>
<p>In Python 2.2, iteration can be implemented separately, and <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
methods can be limited to classes that really do support random access.  The
basic idea of iterators is  simple.  A new built-in function, <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code>
or <code class="docutils literal notranslate"><span class="pre">iter(C,</span> <span class="pre">sentinel)</span></code>, is used to get an iterator. <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code> returns
an iterator for the object <em>obj</em>, while <code class="docutils literal notranslate"><span class="pre">iter(C,</span> <span class="pre">sentinel)</span></code> returns an
iterator that will invoke the callable object <em>C</em> until it returns <em>sentinel</em> to
signal that the iterator is done.</p>
<p>Python classes can define an <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method, which should create and
return a new iterator for the object; if the object is its own iterator, this
method can just return <code class="docutils literal notranslate"><span class="pre">self</span></code>.  In particular, iterators will usually be their
own iterators.  Extension types implemented in C can implement a <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a>
function in order to return an iterator, and extension types that want to behave
as iterators can define a <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a> function.</p>
<p>总结一下，迭代器实际上做什么？它们有一个必需的方法 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a>，该方法不接受任何参数并返回下一个值。当没有更多的值可以返回时，调用 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 应该引发 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常。以下是一个简单的例子来说明迭代器的工作原理：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">i</span>
<span class="go">&lt;iterator object at 0x8116870&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">StopIteration</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>In 2.2, Python's <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> statement no longer expects a sequence; it
expects something for which <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> will return an iterator. For backward
compatibility and convenience, an iterator is automatically constructed for
sequences that don't implement <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> or a <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> slot, so
<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">[1,2,3]</span></code> will still work.  Wherever the Python interpreter loops
over a sequence, it's been changed to use the iterator protocol.  This means you
can do things like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>迭代器支持已被添加到Python的一些基本类型中。对字典调用 <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 会返回一个迭代器，该迭代器遍历字典的键，如下所示：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Jan&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Feb&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Mar&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Apr&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;May&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;Jun&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
<span class="gp">... </span>     <span class="s1">&#39;Jul&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;Aug&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;Sep&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;Oct&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;Nov&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;Dec&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span> <span class="n">key</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">Mar 3</span>
<span class="go">Feb 2</span>
<span class="go">Aug 8</span>
<span class="go">Sep 9</span>
<span class="go">May 5</span>
<span class="go">Jun 6</span>
<span class="go">Jul 7</span>
<span class="go">Jan 1</span>
<span class="go">Apr 4</span>
<span class="go">Nov 11</span>
<span class="go">Dec 12</span>
<span class="go">Oct 10</span>
</pre></div>
</div>
<p>That's just the default behaviour.  If you want to iterate over keys, values, or
key/value pairs, you can explicitly call the <code class="xref py py-meth docutils literal notranslate"><span class="pre">iterkeys()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">itervalues()</span></code>, or <code class="xref py py-meth docutils literal notranslate"><span class="pre">iteritems()</span></code> methods to get an appropriate iterator.
In a minor related change, the <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> operator now works on dictionaries,
so <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">in</span> <span class="pre">dict</span></code> is now equivalent to <code class="docutils literal notranslate"><span class="pre">dict.has_key(key)</span></code>.</p>
<p>文件也提供了一个迭代器，它会调用 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 方法，直到文件中没有更多的行。这意味着你现在可以使用类似这样的代码来读取文件的每一行：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
    <span class="c1"># do something for each line</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>请注意，你只能在迭代器中向前移动；没有办法获取前一个元素、重置迭代器或复制迭代器。一个迭代器对象可以提供这些额外的功能，但迭代器协议只要求有一个 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 方法。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0234"><strong>PEP 234</strong></a> - 迭代器</dt><dd><p>由 Ka-Ping Yee 和 GvR 撰写；由 Python Labs 小组（主要由 GvR 和 Tim Peters）实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-255-simple-generators">
<h2>PEP 255: 简单的生成器<a class="headerlink" href="#pep-255-simple-generators" title="永久链接至标题">¶</a></h2>
<p>生成器是另一个新增特性，它是与迭代器的引入相互关联的。</p>
<p>你一定熟悉在Python或C语言中函数调用的工作方式。当你调用一个函数时，它会获得一个私有命名空间，在这个命名空间中创建其局部变量。当函数执行到 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句时，这些局部变量会被销毁，并将结果值返回给调用者。稍后对同一个函数的调用将获得一套全新的局部变量。但，如果局部变量在函数退出时不被丢弃呢？如果你可以在函数停止的地方稍后恢复执行呢？这就是生成器所提供的功能；它们可以被视为可恢复的函数。</p>
<p>这里是一个生成器函数的最简示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_ints</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p>一个新的关键字 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 被引入用于生成器。任何包含 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句的函数都是生成器函数；这由Python的字节码编译器检测到，并因此对函数进行特殊编译。由于引入了一个新的关键字，生成器必须通过在模块的源代码顶部附近包含一条 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generators</span></code> 语句来显式启用。在Python 2.3中，这条语句将变得不再必要。</p>
<p>当你调用一个生成器函数时，它不会返回单个值；相反，它返回一个支持迭代器协议的生成器对象。在执行 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句时，生成器输出 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的值，类似于 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句。<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 和 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 语句之间的重大区别在于，当到达 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 时，生成器的执行状态被挂起，并且局部变量被保留。在下一次调用生成器的 <code class="docutils literal notranslate"><span class="pre">next()</span></code> 方法时，函数将立即在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句之后恢复执行。（由于复杂的原因，<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句不允许在 <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> ... <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 语句的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 块中使用；请阅读 <span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 255</strong></a> 以获得关于 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 和异常交互的详细解释。）</p>
<p>这里是 <code class="xref py py-func docutils literal notranslate"><span class="pre">generate_ints()</span></code> 生成器的用法示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generate_ints</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object at 0x8117f90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">generate_ints</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>你可以等价地写成 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">generate_ints(5)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a,b,c</span> <span class="pre">=</span> <span class="pre">generate_ints(3)</span></code>。</p>
<p>在生成器函数内部， <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句只能不带值使用，并表示值的生成过程结束；之后，生成器不能再返回任何值。在生成器函数内部，带值的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code>，例如 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">5</span></code>，是语法错误。生成器结果的结束也可以通过手动引发 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常来指示，或者只是让执行流自然地从函数底部流出。</p>
<p>你可以通过编写自己的类并将生成器的所有局部变量存储为实例变量，手动实现生成器的效果。例如，返回一个整数列表可以通过将 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> 设置为0，并让 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 方法递增 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> 并返回它。然而，对于一个中等复杂的生成器，编写一个相应的类将会更加混乱。<code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> 包含了一些更有趣的例子。其中最简单的一个使用生成器递归实现了树的中序遍历：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A recursive generator that generates Tree leaves in in-order.</span>
<span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">yield</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
<p>在 <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> 中还有另外两个例子，它们分别解决了N皇后问题（在$NxN$的棋盘上放置$N$个皇后，使得没有任何皇后威胁到其他皇后）和骑士巡游问题（在$NxN$的棋盘上，骑士访问每一个方格且不重复访问任何方格的路径）。</p>
<p>The idea of generators comes from other programming languages, especially Icon
(<a class="reference external" href="https://www.cs.arizona.edu/icon/">https://www.cs.arizona.edu/icon/</a>), where the idea of generators is central.  In
Icon, every expression and function call behaves like a generator.  One example
from &quot;An Overview of the Icon Programming Language&quot; at
<a class="reference external" href="https://www.cs.arizona.edu/icon/docs/ipd266.htm">https://www.cs.arizona.edu/icon/docs/ipd266.htm</a> gives an idea of what this looks
like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sentence</span> <span class="o">:=</span> <span class="s2">&quot;Store it in the neighboring harbor&quot;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">sentence</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="n">then</span> <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>In Icon the <code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code> function returns the indexes at which the substring
&quot;or&quot; is found: 3, 23, 33.  In the <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> statement, <code class="docutils literal notranslate"><span class="pre">i</span></code> is first
assigned a value of 3, but 3 is less than 5, so the comparison fails, and Icon
retries it with the second value of 23.  23 is greater than 5, so the comparison
now succeeds, and the code prints the value 23 to the screen.</p>
<p>Python 并没有像 Icon 那样将生成器作为核心概念来采纳。生成器被认为是 Python 核心语言的一部分，但学习或使用它们并不是强制性的；如果它们不能解决你的问题，可以完全忽略它们。与 Icon 相比，Python 的一个新颖特性是生成器的状态表示为一个具体对象（迭代器），该对象可以传递给其他函数或存储在数据结构中。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 255</strong></a> - 简单生成器</dt><dd><p>由 Neil Schemenauer, Tim Peters, Magnus Lie Hetland 撰写。 主要由 Neil Schemenauer 和 Tim Peters 实现，并包含来自 Python Labs 团队的修正。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-237-unifying-long-integers-and-integers">
<h2>PEP 237: 统一长整数和整数<a class="headerlink" href="#pep-237-unifying-long-integers-and-integers" title="永久链接至标题">¶</a></h2>
<p>In recent versions, the distinction between regular integers, which are 32-bit
values on most machines, and long integers, which can be of arbitrary size, was
becoming an annoyance.  For example, on platforms that support files larger than
<code class="docutils literal notranslate"><span class="pre">2**32</span></code> bytes, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> method of file objects has to return a long
integer. However, there were various bits of Python that expected plain integers
and would raise an error if a long integer was provided instead.  For example,
in Python 1.5, only regular integers could be used as a slice index, and
<code class="docutils literal notranslate"><span class="pre">'abc'[1L:]</span></code> would raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception with the message 'slice
index must be int'.</p>
<p>Python 2.2 将根据需要将数值从短整数转换为长整数。'L' 后缀不再需要用于表示长整数字面量，因为现在编译器会自动选择适当的类型。（在未来的 2.x 版本的 Python 中，使用 'L' 后缀将被不鼓励，并在 Python 2.4 中触发警告，可能在 Python 3.0 中被移除。）许多以前会引发 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 的操作现在会返回一个长整数作为结果。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1234567890123</span>
<span class="go">1234567890123L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">**</span> <span class="mi">64</span>
<span class="go">18446744073709551616L</span>
</pre></div>
</div>
<p>在大多数情况下，整数和长整数现在将被视为相同。你仍然可以使用内置的 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 函数区分它们，但这很少需要。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> - 统一长整数和整数</dt><dd><p>由 Moshe Zadka 和 Guido van Rossum 撰写 ; 大部分由 Guido van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-238-changing-the-division-operator">
<h2>PEP 238：修改除法运算符<a class="headerlink" href="#pep-238-changing-the-division-operator" title="永久链接至标题">¶</a></h2>
<p>Python 2.2中最具争议的变化预示着修复一个自Python诞生以来的旧设计缺陷的努力的开始。目前，Python的除法操作符 <code class="docutils literal notranslate"><span class="pre">/</span></code> 在接收两个整数参数时表现得像C语言的除法操作符：它返回一个被截断为整数的结果。例如，<code class="docutils literal notranslate"><span class="pre">3/2</span></code> 是1，而不是1.5，<code class="docutils literal notranslate"><span class="pre">(-1)/2</span></code> 是-1，而不是-0.5。这意味着除法的结果可能会根据两个操作数的类型而意外变化，并且由于Python是动态类型的，确定操作数的可能类型可能会很困难。</p>
<p>（争议在于这是否*真的*算是一个设计缺陷，以及是否值得为了修复它而破坏现有代码。这在python-dev上引发了无休止的讨论，并在2001年7月爆发成一场在 <em class="newsgroup">comp.lang.python</em> 的充满讽刺性言辞的风暴。我不会在这里为任何一方辩护，只会描述在2.2中实现的内容。请阅读 <span class="target" id="index-52"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a> 以获取争论和反驳的摘要。）</p>
<p>由于这一变化可能会破坏现有代码，因此它正在非常逐步地引入。Python 2.2 开始了这一过渡，但直到 Python 3.0 这一转换才会完全完成。</p>
<p>首先，我将借用一些来自 <span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a> 的术语。“真除法”是大多数非程序员所熟悉的除法：3/2是1.5，1/4是0.25，等等。“地板除法”是Python的 <code class="docutils literal notranslate"><span class="pre">/</span></code> 操作符在给定整数操作数时当前执行的操作；其结果是真除法返回值的地板值。“经典除法”是当前 <code class="docutils literal notranslate"><span class="pre">/</span></code> 操作符的混合行为；当操作数是整数时，它返回地板除法的结果，而当其中一个操作数是浮点数时，它返回真除法的结果。</p>
<p>Python 2.2 引入了以下变化：</p>
<ul>
<li><p>一个新的操作符，<code class="docutils literal notranslate"><span class="pre">//</span></code> 是地板除法操作符。 （是的，我们知道它看起来像 C++ 的注释符号。） <code class="docutils literal notranslate"><span class="pre">//</span></code> <em>始终</em> 执行地板除法，无论其操作数的类型是什么，因此 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">//</span> <span class="pre">2</span></code> 是 0，<code class="docutils literal notranslate"><span class="pre">1.0</span> <span class="pre">//</span> <span class="pre">2.0</span></code> 也是0.0。</p>
<p><code class="docutils literal notranslate"><span class="pre">//</span></code> 操作符在Python 2.2中始终可用；你不需要通过 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句来启用它。</p>
</li>
<li><p>通过在模块中包含 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>，<code class="docutils literal notranslate"><span class="pre">/``操作符将被更改为返回真除法的结果，因此</span> <span class="pre">``1/2</span></code> 是0.5。如果没有这条 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句，<code class="docutils literal notranslate"><span class="pre">/</span></code> 仍然表示经典除法。<code class="docutils literal notranslate"><span class="pre">/</span></code> 的默认含义在Python 3.0之前不会改变。</p></li>
<li><p>Classes can define methods called <a class="reference internal" href="../reference/datamodel.html#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a>
to overload the two division operators.  At the C level, there are also slots in
the <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> structure so extension types can define the two
operators.</p></li>
<li><p>Python 2.2 支持一些命令行参数，用于测试代码是否能在除法语义改变的情况下正常工作。运行 Python 并使用 -Q warn 选项时，当对两个整数应用除法时会发出警告。你可以利用这个功能找到受影响的代码并进行修复。默认情况下，Python 2.2 会执行经典除法而不会发出警告；在 Python 2.3 中，警告将默认开启。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a>：改变除法运算符</dt><dd><p>由 Moshe Zadka 和 Guido van Rossum 撰写 ; 由 Guido van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="unicode-changes">
<h2>Unicode 的改变<a class="headerlink" href="#unicode-changes" title="永久链接至标题">¶</a></h2>
<p>Python的Unicode支持在2.2版本中有所增强。Unicode字符串通常以UCS-2形式存储，即16位无符号整数。通过向配置脚本提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-unicode=ucs4</span></code> 选项，Python 2.2也可以编译为使用UCS-4（32位无符号整数）作为其内部编码。（也可以指定 <code class="xref std std-option docutils literal notranslate"><span class="pre">--disable-unicode</span></code> 选项来完全禁用Unicode支持。）</p>
<p>When built to use UCS-4 (a &quot;wide Python&quot;), the interpreter can natively handle
Unicode characters from U+000000 to U+110000, so the range of legal values for
the <code class="xref py py-func docutils literal notranslate"><span class="pre">unichr()</span></code> function is expanded accordingly.  Using an interpreter
compiled to use UCS-2 (a &quot;narrow Python&quot;), values greater than 65535 will still
cause <code class="xref py py-func docutils literal notranslate"><span class="pre">unichr()</span></code> to raise a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> exception. This is all
described in <span class="target" id="index-14"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0261"><strong>PEP 261</strong></a>, &quot;Support for 'wide' Unicode characters&quot;; consult it for
further details.</p>
<p>Another change is simpler to explain. Since their introduction, Unicode strings
have supported an <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> method to convert the string to a selected
encoding such as UTF-8 or Latin-1.  A symmetric <code class="docutils literal notranslate"><span class="pre">decode([*encoding*])</span></code>
method has been added to 8-bit strings (though not to Unicode strings) in 2.2.
<code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> assumes that the string is in the specified encoding and decodes
it, returning whatever is returned by the codec.</p>
<p>利用这一新特性，编解码器被添加用于与Unicode不直接相关的任务。例如，已经添加了用于uu编码、MIME的base64编码以及使用 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块进行压缩的编解码器：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Here is a lengthy piece of redundant, overly verbose,</span>
<span class="gp">... </span><span class="s2">and repetitive text.</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">&#39;x\x9c\r\xc9\xc1\r\x80 \x10\x04\xc0?Ul...&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">)</span>
<span class="go">&#39;Here is a lengthy piece of redundant, overly verbose,\nand repetitive text.\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;uu&#39;</span><span class="p">)</span>
<span class="go">begin 666 &lt;data&gt;</span>
<span class="go">M2&amp;5R92!I&lt;R!A(&amp;QE;F=T:&#39;D@&lt;&amp;EE8V4@;V8@&lt;F5D=6YD86YT+&quot;!O=F5R;&#39;D@</span>
<span class="go">&gt;=F5R8F]S92P*86YD(&#39;)E&lt;&amp;5T:71I=F4@=&amp;5X=&quot;X*</span>

<span class="go">end</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;sheesh&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;rot-13&#39;</span><span class="p">)</span>
<span class="go">&#39;furrfu&#39;</span>
</pre></div>
</div>
<p>To convert a class instance to Unicode, a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code> method can be
defined by a class, analogous to <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code> were implemented by
Marc-André Lemburg.  The changes to support using UCS-4 internally were
implemented by Fredrik Lundh and Martin von Löwis.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0261"><strong>PEP 261</strong></a> - 对 '宽' Unicode 字符的支持</dt><dd><p>由 Paul Prescod 编写。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-227-nested-scopes">
<h2>PEP 227: 嵌套的作用域<a class="headerlink" href="#pep-227-nested-scopes" title="永久链接至标题">¶</a></h2>
<p>在Python 2.1中，静态嵌套作用域作为一个可选特性被添加，需要通过 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">nested_scopes</span></code> 指令来启用。在2.2版本中，嵌套作用域不再需要特别启用，现在总是存在。本节的其余部分是从我的《Python 2.1的新特性》文档中复制的嵌套作用域描述；如果你在2.1发布时已经阅读过，可以跳过本节的其余部分。</p>
<p>Python 2.1 中的最大改变是 Python 的作用域规则，在Python 2.2中得到完善。 在 Python 2.0 中，任意给定的时刻至多使用三个命名空间来查找变量名称：局部、模块和内置命名空间。 这往往会导致令人吃惊的结果因为它与人们直觉上的预期不相匹配。 例如，一个嵌套的递归函数将不起作用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The function <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> will always raise a <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> exception, because
the binding of the name <code class="docutils literal notranslate"><span class="pre">g</span></code> isn't in either its local namespace or in the
module-level namespace.  This isn't much of a problem in practice (how often do
you recursively define interior functions like this?), but this also made using
the <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> expression clumsier, and this was a problem in practice.
In code which uses <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> you can often find local variables being
copied by passing them as the default values of arguments.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="s2">&quot;Return list of any entries equal to &#39;name&#39;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p>结果将会严重损害以高度函数式风格编写的 Python 代码的可读性。</p>
<p>Python 2.2 最显著的改变是增加了静态作用域这一语言特征来解决此问题。 作为它的第一项影响，在上述示例中的 <code class="docutils literal notranslate"><span class="pre">name=name</span></code> 默认参数现在将不再必要。 简单地说，当一个函数内部的给定变量名没有被赋值时（通过赋值语句，或者 <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>, <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 或 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句），对该变量的引用将在外层作用域的局部命名空间中查找。 对于该规则的更详细解释，以及具体实现的分析，请参阅相应的 PEP。</p>
<p>对于同时在模块层级和包含下层函数定义的函数内部局部变量使用了相同变量名的代码来说这项改变可能会导致一些兼容性问题。 不过这看来不太可能发生，因为阅读这样的代码本来就会相当令人困惑。</p>
<p>此项改变的一个附带影响是在特定条件下函数作用域内部 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句将不允许使用。 Python 参考手册已经写明 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 仅在模块最高层级上是可用的，但此前 CPython 解释器从未强制实施此规则。 作为嵌套作用域具体实现的一部分，将 Python 源码转为字节码的编译器会生成不同的代码来访问某个包含作用域内的变量。 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会使得编译器无法正确执行，因为它们会向局部命名空间添加在编译时还不存在的名称。 为此，如果一个函数包含带有自由变量的函数定义或 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式，编译器将通过引发 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常来提示。</p>
<p>为了使前面的解释更清楚，下面是一个例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="c1"># The next line is a syntax error</span>
    <span class="n">exec</span> <span class="s1">&#39;x=2&#39;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>包含 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句的第 4 行有语法错误，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 将定义一个名为 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的新局部变量，它的值应当被 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 访问。</p>
<p>这应该不会是太大的限制，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 在多数 Python 代码中都极少被使用（而当它被使用时，往往也是个存在糟糕设计的信号）。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0227"><strong>PEP 227</strong></a> - 静态嵌套作用域</dt><dd><p>由 Jeremy Hylton 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="new-and-improved-modules">
<h2>新增和改进的模块<a class="headerlink" href="#new-and-improved-modules" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code> module was contributed to the standard library by Fredrik
Lundh, providing support for writing XML-RPC clients.  XML-RPC is a simple
remote procedure call protocol built on top of HTTP and XML. For example, the
following snippet retrieves a list of RSS channels from the O'Reilly Network,
and then  lists the recent headlines for one channel:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpclib</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">xmlrpclib</span><span class="o">.</span><span class="n">Server</span><span class="p">(</span>
      <span class="s1">&#39;http://www.oreillynet.com/meerkat/xml-rpc/server.php&#39;</span><span class="p">)</span>
<span class="n">channels</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">meerkat</span><span class="o">.</span><span class="n">getChannels</span><span class="p">()</span>
<span class="c1"># channels is a list of dictionaries, like this:</span>
<span class="c1"># [{&#39;id&#39;: 4, &#39;title&#39;: &#39;Freshmeat Daily News&#39;}</span>
<span class="c1">#  {&#39;id&#39;: 190, &#39;title&#39;: &#39;32Bits Online&#39;},</span>
<span class="c1">#  {&#39;id&#39;: 4549, &#39;title&#39;: &#39;3DGamers&#39;}, ... ]</span>

<span class="c1"># Get the items for one channel</span>
<span class="n">items</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">meerkat</span><span class="o">.</span><span class="n">getItems</span><span class="p">(</span> <span class="p">{</span><span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span> <span class="p">)</span>

<span class="c1"># &#39;items&#39; is another list of dictionaries, like this:</span>
<span class="c1"># [{&#39;link&#39;: &#39;http://freshmeat.net/releases/52719/&#39;,</span>
<span class="c1">#   &#39;description&#39;: &#39;A utility which converts HTML to XSL FO.&#39;,</span>
<span class="c1">#   &#39;title&#39;: &#39;html2fo 0.3 (Default)&#39;}, ... ]</span>
</pre></div>
</div>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code> module makes it easy to create straightforward
XML-RPC servers.  See <a class="reference external" href="http://xmlrpc.scripting.com/">http://xmlrpc.scripting.com/</a> for more information about XML-RPC.</p>
</li>
<li><p>新的 <a class="reference internal" href="../library/hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> 模块实现了由 <span class="target" id="index-57"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2104.html"><strong>RFC 2104</strong></a> 描述的HMAC算法。（由Gerhard Häring贡献。）</p></li>
<li><p>Several functions that originally returned lengthy tuples now return
pseudo-sequences that still behave like tuples but also have mnemonic attributes such
as memberst_mtime or <code class="xref py py-attr docutils literal notranslate"><span class="pre">tm_year</span></code>. The enhanced functions include
<a class="reference internal" href="../library/stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-func docutils literal notranslate"><span class="pre">stat()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">fstat()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">statvfs()</span></code>, and <code class="xref py py-func docutils literal notranslate"><span class="pre">fstatvfs()</span></code> in the
<a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> module, and <code class="xref py py-func docutils literal notranslate"><span class="pre">localtime()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">gmtime()</span></code>, and <code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code> in
the <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> module.</p>
<p>例如，使用旧的元组来获取文件的大小时，你可能会写成 <code class="docutils literal notranslate"><span class="pre">file_size</span> <span class="pre">=</span> <span class="pre">os.stat(filename)[stat.ST_SIZE]</span></code> ，但现在可以更清晰地写成 <code class="docutils literal notranslate"><span class="pre">file_size</span> <span class="pre">=</span> <span class="pre">os.stat(filename).st_size</span></code>。</p>
<p>此特性的初始补丁由 Nick Mathewson 贡献。</p>
</li>
<li><p>Python 的分析器进行了大量的重构，并纠正了其输出中的各种错误。（由 Fred L. Drake, Jr. 和 Tim Peters 贡献。）</p></li>
<li><p><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块可以编译为支持IPv6；为Python的配置脚本指定 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-ipv6</span></code> 选项。（由Jun-ichiro &quot;itojun&quot; Hagino贡献。）</p></li>
<li><p>Two new format characters were added to the <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module for 64-bit
integers on platforms that support the C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> type.  <code class="docutils literal notranslate"><span class="pre">q</span></code> is for
a signed 64-bit integer, and <code class="docutils literal notranslate"><span class="pre">Q</span></code> is for an unsigned one.  The value is
returned in Python's long integer type.  (Contributed by Tim Peters.)</p></li>
<li><p>在解释器的交互模式下，有一个新的内置函数 <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>，它使用在Python 2.1 中引入的 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块来提供交互式帮助。 <code class="docutils literal notranslate"><span class="pre">help(object)</span></code> 显示关于*object*的任何可用帮助文本。不带参数调用 <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 会进入一个在线帮助工具，在那里你可以输入函数、类或模块的名称来阅读它们的帮助文本。（由Guido van Rossum贡献，使用Ka-Ping Yee的 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块。）</p></li>
<li><p>Various bugfixes and performance improvements have been made to the SRE engine
underlying the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> module.  For example, the <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> and
<a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> functions have been rewritten in C.  Another contributed patch
speeds up certain Unicode character ranges by a factor of two, and a new
<code class="xref py py-meth docutils literal notranslate"><span class="pre">finditer()</span></code>  method that returns an iterator over all the non-overlapping
matches in  a given string.  (SRE is maintained by Fredrik Lundh.  The
BIGCHARSET patch was contributed by Martin von Löwis.)</p></li>
<li><p><a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> 模块现在支持 <span class="target" id="index-58"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2487.html"><strong>RFC 2487</strong></a>：&quot;Secure SMTP over TLS&quot;，因此现在可以加密Python程序与接收消息的邮件传输代理之间的SMTP流量。<a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> 还支持SMTP身份验证。（由Gerhard Häring贡献。）</p></li>
<li><p><a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> 模块由 Piers Lauder 维护，支持几个新扩展: <span class="target" id="index-59"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2342.html"><strong>RFC 2342</strong></a> 中定义的 NAMESPACE 扩展、SORT、GETACL和SETACL。（由 Anthony Baxter 和 Michel Pelletier 贡献。）</p></li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">rfc822</span></code> module's parsing of email addresses is now compliant with
<span class="target" id="index-20"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html"><strong>RFC 2822</strong></a>, an update to <span class="target" id="index-21"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a>.  (The module's name is <em>not</em> going to be
changed to <code class="docutils literal notranslate"><span class="pre">rfc2822</span></code>.)  A new package, <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>, has also been added for
parsing and generating e-mail messages.  (Contributed by Barry Warsaw, and
arising out of his work on Mailman.)</p></li>
<li><p>The <a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> module now contains a new <code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code> class for
producing human-readable lists of changes (a &quot;delta&quot;) between two sequences of
lines of text.  There are also two generator functions, <code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">restore()</span></code>, which respectively return a delta from two sequences, or one of
the original sequences from a delta. (Grunt work contributed by David Goodger,
from ndiff.py code by Tim Peters who then did the generatorization.)</p></li>
<li><p>New constants <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_letters</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_lowercase</span></code>, and
<code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_uppercase</span></code> were added to the <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> module.  There were
several modules in the standard library that used <code class="xref py py-const docutils literal notranslate"><span class="pre">string.letters</span></code> to
mean the ranges A-Za-z, but that assumption is incorrect when locales are in
use, because <code class="xref py py-const docutils literal notranslate"><span class="pre">string.letters</span></code> varies depending on the set of legal
characters defined by the current locale.  The buggy modules have all been fixed
to use <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_letters</span></code> instead. (Reported by an unknown person; fixed by
Fred L. Drake, Jr.)</p></li>
<li><p>The <a class="reference internal" href="../library/mimetypes.html#module-mimetypes" title="mimetypes: Mapping of filename extensions to MIME types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mimetypes</span></code></a> module now makes it easier to use alternative MIME-type
databases by the addition of a <code class="xref py py-class docutils literal notranslate"><span class="pre">MimeTypes</span></code> class, which takes a list of
filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)</p></li>
<li><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Timer</span></code> class was added to the <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> module that allows
scheduling an activity to happen at some future time.  (Contributed by Itamar
Shtull-Trauring.)</p></li>
</ul>
</section>
<section id="interpreter-changes-and-fixes">
<h2>解释器的改变和修正<a class="headerlink" href="#interpreter-changes-and-fixes" title="永久链接至标题">¶</a></h2>
<p>有些变化只会影响那些在 C 级别处理 Python 解释器的人，因为他们正在编写 Python 扩展模块、嵌入解释器或仅仅是在修改解释器本身。如果你只编写 Python 代码，这里描述的变化对你几乎没有影响。</p>
<ul>
<li><p>性能分析和追踪函数现在可以用 C 语言来实现，相比基于 Python 的函数能够显著提高运行速度并能够减少性能分析和追踪的资源开销。 Python 开发环境的编写者对此将会很感兴趣。 Python 的 API 增加了两个新的 C 函数，<a class="reference internal" href="../c-api/init.html#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 和 <a class="reference internal" href="../c-api/init.html#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a>。 现有的 <a class="reference internal" href="../library/sys.html#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setprofile()</span></code></a> 和 <a class="reference internal" href="../library/sys.html#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.settrace()</span></code></a> 函数仍然存在，并已简单地更改为使用新的 C 层级接口。 （由 Fred L. Drake, Jr. 贡献。）</p></li>
<li><p>Another low-level API, primarily of interest to implementors of Python
debuggers and development tools, was added. <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_Head" title="PyInterpreterState_Head"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Head()</span></code></a> and
<a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_Next" title="PyInterpreterState_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Next()</span></code></a> let a caller walk through all the existing
interpreter objects; <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_ThreadHead" title="PyInterpreterState_ThreadHead"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_ThreadHead()</span></code></a> and
<a class="reference internal" href="../c-api/init.html#c.PyThreadState_Next" title="PyThreadState_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Next()</span></code></a> allow looping over all the thread states for a given
interpreter.  (Contributed by David Beazley.)</p></li>
<li><p>垃圾收集器的 C 级接口已经发生了变化，使得编写支持垃圾收集的扩展类型和调试函数误用变得更容易。各种函数的语义略有不同，因此需要重命名一系列函数。使用旧 API 的扩展仍然可以编译，但不会参与垃圾收集，因此应优先考虑将它们更新为 2.2 版本。</p>
<p>要将一个扩展模块升级至新 API，请执行下列步骤:</p>
</li>
<li><p>将 <code class="xref c c-func docutils literal notranslate"><span class="pre">Py_TPFLAGS_GC()</span></code> 重命名为 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyTPFLAGS_HAVE_GC()</span></code>。</p></li>
<li><dl class="simple">
<dt>使用 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a> 或 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_NewVar()</span></code></a> 来分配</dt><dd><p>对象，并使用 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a> 来释放它们。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>将 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Init()</span></code> 重命名为 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Track" title="PyObject_GC_Track"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Track()</span></code></a> 并</dt><dd><p>将 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Fini()</span></code> 重命名为 <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_UnTrack()</span></code></a>。</p>
</dd>
</dl>
</li>
<li><p>将 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyGC_HEAD_SIZE()</span></code> 从对象大小计算中移除。</p></li>
<li><p>移除对 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_AS_GC()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_FROM_GC()</span></code> 的调用。</p></li>
<li><p>向 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 添加了一个新的 <code class="docutils literal notranslate"><span class="pre">et</span></code> 格式序列；<code class="docutils literal notranslate"><span class="pre">et</span></code> 接受一个形参和一个编码格式名称，如果该形参值是一个 Unicode 字符串则将其转换为给定的编码格式，或者如果它是一个 8 比特位字符串则让其保持原样，即假定它已经使用了适当的编码格式。 这不同于 <code class="docutils literal notranslate"><span class="pre">es</span></code> 格式字符，它假定该 8 比特位字符串是使用 Python 默认的 ASCII 编码格式并将其转换为指定的新编码格式。 （由 M.-A. Lemburg 贡献，用于下一节所描述的 Windows 上的 MBCS 支持。）</p></li>
<li><p>A different argument parsing function, <a class="reference internal" href="../c-api/arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a>, has been
added that's simpler and presumably faster.  Instead of specifying a format
string, the caller simply gives the minimum and maximum number of arguments
expected, and a set of pointers to <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a> variables that will be
filled in with argument values.</p></li>
<li><p>Two new flags <a class="reference internal" href="../c-api/structures.html#METH_NOARGS" title="METH_NOARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> and <a class="reference internal" href="../c-api/structures.html#METH_O" title="METH_O"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_O</span></code></a> are available in method
definition tables to simplify implementation of methods with no arguments or a
single untyped argument. Calling such methods is more efficient than calling a
corresponding method that uses <a class="reference internal" href="../c-api/structures.html#METH_VARARGS" title="METH_VARARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_VARARGS</span></code></a>.  Also, the old
<code class="xref py py-const docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code> style of writing C methods is  now officially deprecated.</p></li>
<li><p>Two new wrapper functions, <a class="reference internal" href="../c-api/conversion.html#c.PyOS_snprintf" title="PyOS_snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_snprintf()</span></code></a> and <a class="reference internal" href="../c-api/conversion.html#c.PyOS_vsnprintf" title="PyOS_vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_vsnprintf()</span></code></a>
were added to provide  cross-platform implementations for the relatively new
<code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code> C lib APIs. In contrast to the standard
<code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">vsprintf()</span></code> functions, the Python versions check the
bounds of the buffer used to protect against buffer overruns. (Contributed by
M.-A. Lemburg.)</p></li>
<li><p><a class="reference internal" href="../c-api/tuple.html#c._PyTuple_Resize" title="_PyTuple_Resize"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyTuple_Resize()</span></code></a> 函数去掉了一个未使用的形参，因此现在它接受 2 个形参而不是 3 个。 第三个参数从未被使用，在将代码从较早的版本移植到 Python 2.2 时可以简单地丢弃它。</p></li>
</ul>
</section>
<section id="other-changes-and-fixes">
<h2>其他的改变和修正<a class="headerlink" href="#other-changes-and-fixes" title="永久链接至标题">¶</a></h2>
<p>像往常一样，源代码树中散布着许多其他改进和错误修复。通过搜索 CVS 更改日志，可以发现 Python 2.1 到 2.2 之间应用了 527 个补丁并修复了 683 个错误；2.2.1 应用了 139 个补丁并修复了 143 个错误；2.2.2 应用了 106 个补丁并修复了 82 个错误。这些数字可能是低估的。</p>
<p>一些较为重要的改变:</p>
<ul>
<li><p>适用于 MacOS 的 Python 端口代码现在保存在主 Python CVS 树中，由 Jack Jansen 维护，并且为了支持 MacOS X，进行了许多更改。</p>
<p>最重要的变化是能够将 Python 作为框架来进行构建，这可以通过在编译 Python 时向配置脚本提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-framework</span></code> 选项来启用。 根据 Jack Jansen 的说法，“这会将一个独立的 Python 安装版加上 OS X 框架‘粘合起来’放到 <code class="file docutils literal notranslate"><span class="pre">/Library/Frameworks/Python.framework</span></code> 中（或者其他选定的位置）。 就目前而言这样做并没有什么直接的额外好处（实际上，这样做还存在必须更改 PATH 才能找到Python 的坏处），但它是创建完整的 Python 应用程序、移植 MacPython IDE、并可能使用 Python 作为标准 OSA 脚本语言及其他更多功能的基础。”</p>
<p>作为 MacOS API 如 windowing, QuickTime, scripting 等的接口的许多 MacPython 工具箱模块已被移植到 OS X，但它们在 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 中被注释掉了。 希望尝试这些模块的人可以手动取消注释它们。</p>
</li>
<li><p>现在将关键字参数传给不接受它们的内置函数会导致引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常，并附带消息 &quot;<em>function</em> takes no keyword arguments&quot;。</p></li>
<li><p>在 Python 2.1 中作为扩展模块加入的弱引用现在已成为核心组成部分，因为它们被用于新式类的实现。 为此 <a class="reference internal" href="../library/exceptions.html#ReferenceError" title="ReferenceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ReferenceError</span></code></a> 异常也已从 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块移出成为一个内置异常。</p></li>
<li><p>由 Tim Peters 编写的新脚本 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/cleanfuture.py</span></code> 可自动从 Python 源代码移除过时的 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句。</p></li>
<li><p>向内置函数 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 添加了一个额外的 <em>flags</em> 参数，以便现在 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句的行为能在模拟的 shell，例如由 IDLE 和其他开发环境所提供的此类工具中被正确地观察。 此特性的描述参见 <span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0264"><strong>PEP 264</strong></a>。 （由 Michael Hudson 贡献。）</p></li>
<li><p>Python 1.6 引入的新许可证与 GPL 不兼容。通过对 2.2 许可证进行一些小的文本修改，这个问题得以解决，因此现在可以合法地将 Python 嵌入到 GPL 授权的程序中。请注意，Python 本身并不是在 GPL 授权下，而是采用一个与 BSD 许可证本质上等效的许可证，这与之前的情况一样。这些许可证更改也应用到了 Python 2.0.1 和 2.1.1 版本中。</p></li>
<li><p>在 Windows 上，当 Python 遇到一个 Unicode 文件名时，现在会将其转换为 MBCS 编码的字符串，这种编码由 Microsoft 文件 API 使用。由于文件 API 明确使用 MBCS 编码，Python 默认选择 ASCII 作为编码方式显得很不方便。在 Unix 上，如果 <code class="docutils literal notranslate"><span class="pre">locale.nl_langinfo(CODESET)</span></code> 可用，Python 将使用本地字符集。（Windows 支持由 Mark Hammond 提供，Marc-André Lemburg 提供协助。Unix 支持由 Martin von Löwis 添加。）</p></li>
<li><p>大文件支持目前已在 Windows 上启用。 （由 Tim Peters 贡献。）</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">Tools/scripts/ftpmirror.py</span></code> 脚本现在会解析 <code class="file docutils literal notranslate"><span class="pre">.netrc</span></code> 文件，如果存在的话。 （由 Mike Romberg 贡献。）</p></li>
<li><p>Some features of the object returned by the <code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> function are now
deprecated, and trigger warnings when they're accessed; they'll disappear in
Python 2.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">xrange</span></code> objects tried to pretend they were full sequence
types by supporting slicing, sequence multiplication, and the <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>
operator, but these features were rarely used and therefore buggy.  The
<code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code> method and the <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code>, and <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code>
attributes are also being deprecated.  At the C level, the fourth argument to
the <code class="xref c c-func docutils literal notranslate"><span class="pre">PyRange_New()</span></code> function, <code class="docutils literal notranslate"><span class="pre">repeat</span></code>, has also been deprecated.</p></li>
<li><p>字典实现中有一堆补丁，主要是为了修复潜在的核心转储问题，这些问题发生在字典中包含的对象悄悄改变其哈希值，或者在它们所包含的字典中发生突变时。那段时间，python-dev 邮件列表进入了一个微妙的节奏：Michael Hudson 发现一个导致核心转储的案例，Tim Peters 修复这个 bug，接着 Michael 又发现另一个案例，如此反复循环。</p></li>
<li><p>在 Windows 上，Python 现在可以使用 Borland C 编译，这要归功于 Stephen Hansen 提供的多个补丁，尽管结果还不完全可用。（但这*确实*是一个进步……）</p></li>
<li><p>另一个 Windows 改进：Wise Solutions 慷慨地向 PythonLabs 提供了他们的 InstallerMaster 8.1 系统。早期的 PythonLabs Windows 安装程序使用的是 Wise 5.0a，已经开始显得过时。（由 Tim Peters 打包。）</p></li>
<li><p>在 Windows 上现在将会导入以 <code class="docutils literal notranslate"><span class="pre">.pyw</span></code> 结尾的文件。 <code class="docutils literal notranslate"><span class="pre">.pyw</span></code> 是 Windows 专属的，用来指明一个脚本需要使用 PYTHONW.EXE 而不是 PYTHON.EXE 来运行以避免弹出 DOS 控制台来显示输出。 该补丁使得导入这样的脚本成为可能，让它们也可以作为模块来使用。 （由 David Bolen 实现。）</p></li>
<li><p>在 Python 会使用 C <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> 函数来加载扩展模块的平台上，现在可以使用 <a class="reference internal" href="../library/sys.html#sys.getdlopenflags" title="sys.getdlopenflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getdlopenflags()</span></code></a> 和 <a class="reference internal" href="../library/sys.html#sys.setdlopenflags" title="sys.setdlopenflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setdlopenflags()</span></code></a> 等函数来设置 <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> 所使用的旗标。 （由 Bram Stolk 贡献。）</p></li>
<li><p>The <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> built-in function no longer supports 3 arguments when
floating-point numbers are supplied. <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> returns <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">z</span></code>,
but this is never useful for floating point numbers, and the final result varies
unpredictably depending on the platform.  A call such as <code class="docutils literal notranslate"><span class="pre">pow(2.0,</span> <span class="pre">8.0,</span> <span class="pre">7.0)</span></code>
will now raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception.</p></li>
</ul>
</section>
<section id="acknowledgements">
<h2>致谢<a class="headerlink" href="#acknowledgements" title="永久链接至标题">¶</a></h2>
<p>作者感谢以下人员为本文的各种草案提供建议，更正和帮助： Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van Rossum, Greg Ward, Edward Welbourne.</p>
</section>
</section>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python 2.2 有什么新变化</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#peps-252-and-253-type-and-class-changes">PEP 252 和 253：类型和类的修改</a><ul>
<li><a class="reference internal" href="#old-and-new-classes">旧式类和新式类</a></li>
<li><a class="reference internal" href="#descriptors">描述器</a></li>
<li><a class="reference internal" href="#multiple-inheritance-the-diamond-rule">多重继承：钻石规则</a></li>
<li><a class="reference internal" href="#attribute-access">属性访问</a></li>
<li><a class="reference internal" href="#related-links">相关链接</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-234-iterators">PEP 234: 迭代器</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 简单的生成器</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: 统一长整数和整数</a></li>
<li><a class="reference internal" href="#pep-238-changing-the-division-operator">PEP 238：修改除法运算符</a></li>
<li><a class="reference internal" href="#unicode-changes">Unicode 的改变</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 嵌套的作用域</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a></li>
<li><a class="reference internal" href="#interpreter-changes-and-fixes">解释器的改变和修正</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="2.3.html"
                        title="上一章">Python 2.3 有什么新变化</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="2.1.html"
                        title="下一章">Python 2.1 有什么新变化</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/whatsnew/2.2.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Python 2.1 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Python 2.3 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.8.20 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 12月 09, 2024.
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>

  </body>
</html>